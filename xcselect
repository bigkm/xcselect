#!/usr/bin/env ruby
require "optparse"
# eye candy.
class String
  def red; colorize(self, "\e[1m\e[31m"); end
  def dark_red; colorize(self, "\e\[31m"); end
  def green; colorize(self, "\e[1m\e[32m"); end
  def dark_green; colorize(self, "\e[32m"); end
  def yellow; colorize(self, "\e[1m\e[33m"); end
  def dark_yellow; colorize(self, "\e[33m"); end
  def blue; colorize(self, "\e[1m\e[34m"); end
  def dark_blue; colorize(self, "\e[34m"); end
  def pur; colorize(self, "\e[1m\e[35m"); end
  def dark_pur; colorize(self, "\e[35m"); end
  def colorize(text, color_code)  
    (STDIN.tty?) ? "#{color_code}#{text}\e[0m" : text
  end
    
  def numeric?
    true if Float(self) rescue false
  end
end

class Xcode
  include Comparable
  attr_accessor :folder, :version, :build
  def initialize(fld)
    @folder = fld
    ver_output = `#{xcodebuild_path} -version`
    @version = ver_output.match(/Xcode (.*)$/)[1]
    @build = ver_output.match(/Build version (.*)$/)[1]
  end

  def xcodebuild_path
    "#{folder}/usr/bin/xcodebuild"
  end
  
  def to_s
    "Xcode: #{folder} - #{version} (#{build})"
  end
  
  def self.find_all
    xcode_builds = `mdfind -name xcodebuild`.chomp.split  
    xcode_builds = xcode_builds.select {|x| x =~ /\/xcodebuild$/ && !(x =~ /^\/(Volumes|usr\/bin\/)/) && File.exists?(x) }
    xcode_objs = xcode_builds.map {|p| 
      Xcode.new p.sub( /\/usr\/bin.*/, '').chomp.strip
      
    }    
    xcode_objs.sort
  end
    
  def self.current_xcode
    `xcode-select -print-path`.chomp
  end
  
  def eql?(o)
    return false if o.nil? 
    return (o.folder == folder && o.version == version && o.build == build)
  end

  def sdks
    `#{xcodebuild_path} -showsdks`
  end

  def set_current
    puts "Enter sudo password to select #{self}"
    `sudo xcode-select -switch #{folder}`
    puts "Set Xcode to #{self}"
  end
  
  def <=>(o)
    res = Float(version) <=> Float(o.version) 
    return res == 0 ?  o.build <=> build : res;


    
  end
end

class Main
  attr_accessor :xcodes, :current
  attr_reader :exit_code 
  def initialize
    @exit_code = 0
    optparse = OptionParser.new do |opts|
      opts.on('-h', '--help', "Display this !!") { puts opts; exit }
      opts.on('-a', '--alt' , "Alternate through all installs") { select_next() ;exit}
      opts.on('-s', '--show' , "Show Current") { show_current() ;exit}
    end
    optparse.parse!
    
    begin
      load_xcodes
      show_menu
    rescue OptionParser::MissingArgument => e
      puts e
      return nil
    rescue Exception => e
      puts e
      puts e.backtrace
      return 
    end
  end
  
  def select_next
    load_xcodes
    if xcodes.size > 1 
      cur_index = xcodes.index(current)
      next_index = (cur_index + 1) % xcodes.size
      xcodes[next_index].set_current
    end
    
    exit
  end
  
  def show_current()
    cur = Xcode.new(Xcode.current_xcode)
    puts cur
    puts cur.sdks
  end
  
  def console_availale
    STDIN.tty?
  end
    
  def show_menu
    puts "Please Select an Xcode install ?\n\n"
    i = 0;
    xopts = xcodes.each do |x|
      puts "   [#{i+=1}]    Xcode #{x.version} (#{x.build}) #{x.folder} #{'*current*' if x.eql? current}"
    end
    print "\nSelection: "
    begin
      return unless console_availale
      input =  STDIN.gets
      input = input.to_i

      if input.zero? or input > xcodes.size
        puts "Invalid Selection"
        @exit_code = 1
      elsif xcodes[input - 1].eql?(current)
        puts "Already Current"
        @exit_code = 2
      else
        new_sel = xcodes[input - 1]
        puts "Enter sudo password to select #{new_sel}"
        new_sel.set_current
        puts "Set Xcode to #{new_sel}"
      end
    rescue Exception => e
      puts e
      puts e.backtrace
    end    
  end
  
  
  def load_xcodes
    @xcodes = Xcode.find_all
    @current = xcodes.select {|x| x.folder == Xcode.current_xcode}.first   
  end
    
  def to_s
    "xcodes = #{xcodes} current = #{current}"
  end
  
  
end

main = Main.new

exit main.exit_code
